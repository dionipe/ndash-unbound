// Utility functions for Bind DNS management

const { exec } = require('child_process');
const fs = require('fs-extra');
const path = require('path');
const config = require('../config');

/**
 * Read a zone file
 * @param {string} zonePath - Path to zone file
 * @returns {Promise<string>} Zone file content
 */
async function readZoneFile(zonePath) {
    try {
        return await fs.readFile(zonePath, 'utf8');
    } catch (error) {
        throw new Error(`Failed to read zone file: ${error.message}`);
    }
}

/**
 * Write to a zone file
 * @param {string} zonePath - Path to zone file
 * @param {string} content - Zone file content
 */
async function writeZoneFile(zonePath, content) {
    try {
        await fs.ensureDir(path.dirname(zonePath));
        await fs.writeFile(zonePath, content, 'utf8');
    } catch (error) {
        throw new Error(`Failed to write zone file: ${error.message}`);
    }
}

/**
 * Execute Bind reload command
 * @returns {Promise<string>} Command output
 */
function reloadBind() {
    return new Promise((resolve, reject) => {
        exec(config.bind.reloadCommand, (error, stdout, stderr) => {
            if (error) {
                reject(new Error(`Bind reload failed: ${stderr || error.message}`));
            } else {
                resolve(stdout);
            }
        });
    });
}

/**
 * Check zone syntax
 * @param {string} zoneName - Zone name
 * @param {string} zonePath - Path to zone file
 * @returns {Promise<boolean>} True if valid
 */
function checkZoneSyntax(zoneName, zonePath) {
    return new Promise((resolve, reject) => {
        exec(`${config.bind.checkCommand} ${zoneName} ${zonePath}`, (error, stdout, stderr) => {
            if (error) {
                reject(new Error(`Zone syntax error: ${stderr || error.message}`));
            } else {
                resolve(true);
            }
        });
    });
}

/**
 * Generate zone file content from zone data
 * @param {Object} zone - Zone object
 * @param {Array} records - Array of record objects
 * @returns {string} Zone file content
 */
function generateZoneFile(zone, records) {
    const ttl = zone.ttl || config.dns.defaultTTL;
    const soa = zone.soa || {
        nameserver: `ns1.${zone.name}.`,
        email: `admin.${zone.name}.`,
        serial: generateSerial(),
        refresh: config.dns.defaultRefresh,
        retry: config.dns.defaultRetry,
        expire: config.dns.defaultExpire,
        minimum: config.dns.defaultMinimum
    };

    let content = `; Zone file for ${zone.name}\n`;
    content += `; Generated by NDash on ${new Date().toISOString()}\n\n`;
    content += `$TTL ${ttl}\n`;
    content += `@ IN SOA ${soa.nameserver} ${soa.email} (\n`;
    content += `    ${soa.serial} ; Serial\n`;
    content += `    ${soa.refresh} ; Refresh\n`;
    content += `    ${soa.retry} ; Retry\n`;
    content += `    ${soa.expire} ; Expire\n`;
    content += `    ${soa.minimum} ) ; Minimum TTL\n\n`;

    // Add records
    records.forEach(record => {
        const name = record.name.padEnd(20);
        const ttlStr = record.ttl ? record.ttl.toString().padEnd(8) : ''.padEnd(8);
        const type = record.type.padEnd(8);
        
        if (record.type === 'MX') {
            content += `${name} ${ttlStr} IN ${type} ${record.priority || 10} ${record.value}\n`;
        } else if (record.type === 'SRV') {
            content += `${name} ${ttlStr} IN ${type} ${record.priority || 10} ${record.weight || 0} ${record.port || 0} ${record.value}\n`;
        } else {
            content += `${name} ${ttlStr} IN ${type} ${record.value}\n`;
        }
    });

    return content;
}

/**
 * Generate serial number (YYYYMMDDNN format)
 * @returns {string} Serial number
 */
function generateSerial() {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    return `${year}${month}${day}01`;
}

/**
 * Validate IP address
 * @param {string} ip - IP address to validate
 * @returns {boolean} True if valid IPv4
 */
function isValidIPv4(ip) {
    const regex = /^(\d{1,3}\.){3}\d{1,3}$/;
    if (!regex.test(ip)) return false;
    
    const parts = ip.split('.');
    return parts.every(part => {
        const num = parseInt(part);
        return num >= 0 && num <= 255;
    });
}

/**
 * Validate domain name
 * @param {string} domain - Domain name to validate
 * @returns {boolean} True if valid
 */
function isValidDomain(domain) {
    const regex = /^[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,}$/i;
    return regex.test(domain);
}

/**
 * Parse zone file to extract records
 * @param {string} content - Zone file content
 * @returns {Array} Array of record objects
 */
function parseZoneFile(content) {
    const records = [];
    const lines = content.split('\n');
    
    lines.forEach(line => {
        line = line.trim();
        if (line.startsWith(';') || line === '') return;
        
        // Basic parsing (simplified)
        const parts = line.split(/\s+/);
        if (parts.length >= 4 && parts.includes('IN')) {
            const inIndex = parts.indexOf('IN');
            records.push({
                name: parts[0],
                type: parts[inIndex + 1],
                value: parts.slice(inIndex + 2).join(' ')
            });
        }
    });
    
    return records;
}

module.exports = {
    readZoneFile,
    writeZoneFile,
    reloadBind,
    checkZoneSyntax,
    generateZoneFile,
    generateSerial,
    isValidIPv4,
    isValidDomain,
    parseZoneFile
};
